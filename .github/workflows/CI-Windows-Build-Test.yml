name: CI-Windows-Build-Test

# Phase 2: Build on cloud, test (CUDA tests skip), publish SDK artifact
# CUDA-agnostic - no knowledge of GPU availability
# CUDA tests skip silently via runtime detection (if_compute_cap_supported)
# Triggers CI-Windows-CUDA-Tests on success for GPU testing

on:
  push:
    branches: [main]
    paths-ignore:
      - '**.md'
      - '.github/docs/**'
      - '.claude/**'
      - 'docs/**'
  pull_request:
    branches: [main]
    paths-ignore:
      - '**.md'
      - '.github/docs/**'
      - '.claude/**'
      - 'docs/**'
  workflow_dispatch:

# Prevent duplicate runs - cancel in-progress runs on same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-test:
    runs-on: windows-latest
    # OpenCV CUDA builds take 3-4 hours with optimized settings
    # Set timeout to allow for potential delays
    timeout-minutes: 330

    env:
      TEST_EXE: build/Release/aprapipesut.exe
      CMAKE_TC_FILE: '${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake'
      VCPKG_DEFAULT_BINARY_CACHE: 'C:\Users\runneradmin\AppData\Local\vcpkg\archives'
      # Use custom triplet with v142 toolset for CUDA 11.8 compatibility
      VCPKG_DEFAULT_TRIPLET: 'x64-windows-cuda'
      VCPKG_OVERLAY_TRIPLETS: '${{ github.workspace }}/vcpkg/triplets/community'

    steps:
    - name: Prepare builder
      run: |
        choco install python --version=3.10.11 --force
        refreshenv
        pip3 install ninja
        pip3 install meson
        choco feature enable -n allowEmptyChecksums
        choco install pkgconfiglite
        choco install cmake --version=3.29.6 --force
        python --version
        cmake --version
        ninja --version
        git --version
        pwsh --version

    - name: Checkout code
      uses: actions/checkout@v3
      with:
        submodules: 'recursive'
        lfs: true
        fetch-depth: 0

    - name: List Submodules
      run: |
        git config --global --add safe.directory "*"
        git submodule status > submodule_ver.txt
        cat submodule_ver.txt
        git rev-list --all --count

    - name: Run VCPKG bootstrap
      run: |
        ./vcpkg/bootstrap-vcpkg.bat
        ./vcpkg/vcpkg.exe integrate install

    - name: Cache dependencies
      id: cache-all
      uses: actions/cache@v3
      with:
        path: ${{ env.VCPKG_DEFAULT_BINARY_CACHE }}
        key: Windows-Unified-8-${{ hashFiles('base/vcpkg.json', 'vcpkg/baseline.json', 'submodule_ver.txt', 'vcpkg/triplets/community/x64-windows-cuda.cmake') }}
        restore-keys: Windows-Unified-

    - name: Clear vcpkg downloads to force fresh Python download
      working-directory: ${{github.workspace}}
      run: Remove-Item vcpkg/downloads -Recurse -Force -ErrorAction SilentlyContinue
      shell: pwsh
      continue-on-error: true

    - name: Make build folder
      run: if (!(Test-Path build)) { New-Item -ItemType Directory -Path build }
      shell: pwsh
      continue-on-error: true

    - name: Add pkg-config to PATH
      shell: pwsh
      run: |
        $env:PATH = "C:\ProgramData\chocolatey\bin;$env:PATH"
        echo "C:\ProgramData\chocolatey\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        Write-Host "Added chocolatey bin to PATH for pkg-config"

    - name: Install CUDA Toolkit 11.8
      uses: Jimver/cuda-toolkit@v0.2.29
      id: cuda-toolkit
      with:
        cuda: '11.8.0'
        # Full installation needed for OpenCV CUDA detection
        # OpenCV requires cublas, cufft, curand, cusparse, npp for CUDA support
        # Don't use sub-packages - install full toolkit

    - name: Verify CUDA Installation and Add to PATH
      run: |
        echo "CUDA_PATH=$env:CUDA_PATH"
        nvcc --version

        # Add CUDA bin to PATH for cmake/vcpkg to find nvcc
        $cudaBin = Join-Path $env:CUDA_PATH "bin"
        echo "$cudaBin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        echo "Added CUDA bin to PATH: $cudaBin"

        # Also add libnvvp for profiling tools
        $cudaLibnvvp = Join-Path $env:CUDA_PATH "libnvvp"
        if (Test-Path $cudaLibnvvp) {
          echo "$cudaLibnvvp" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        }
      shell: pwsh

    - name: Install CUDA Visual Studio Integration (MSBuildExtensions)
      run: |
        echo "=== Installing CUDA Visual Studio Integration ==="

        # Source: CUDA Toolkit MSBuildExtensions
        $cudaMSBuildSrc = Join-Path $env:CUDA_PATH "extras\visual_studio_integration\MSBuildExtensions"

        # We need to copy CUDA integration to BOTH v170 and v142 folders:
        # - v170: Used by vcpkg when building dependencies (VS 2022 default)
        # - v142: Used by main project build with -T v142 toolset (CUDA 11.8 requirement)
        $vsBase = "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Microsoft\VC"
        $destinations = @(
          "$vsBase\v170\BuildCustomizations",
          "$vsBase\v142\BuildCustomizations"
        )

        echo "Source: $cudaMSBuildSrc"

        if (!(Test-Path $cudaMSBuildSrc)) {
          echo "WARNING: CUDA MSBuildExtensions not found at $cudaMSBuildSrc"
          echo "Listing CUDA extras directory:"
          Get-ChildItem -Path (Join-Path $env:CUDA_PATH "extras") -Recurse -Depth 2 | ForEach-Object { echo $_.FullName }
          exit 0
        }

        foreach ($dest in $destinations) {
          echo ""
          echo "Copying to: $dest"

          if (!(Test-Path $dest)) {
            echo "  Creating directory: $dest"
            New-Item -ItemType Directory -Path $dest -Force | Out-Null
          }

          Get-ChildItem -Path $cudaMSBuildSrc | ForEach-Object {
            $destFile = Join-Path $dest $_.Name
            Copy-Item $_.FullName $destFile -Force
            echo "  Copied: $($_.Name)"
          }
        }

        echo ""
        echo "=== CUDA Visual Studio Integration Complete ==="
        echo "Verifying CUDA files in v170:"
        Get-ChildItem -Path "$vsBase\v170\BuildCustomizations" -Filter "CUDA*" | ForEach-Object { echo "  $($_.Name)" }
        echo "Verifying CUDA files in v142:"
        Get-ChildItem -Path "$vsBase\v142\BuildCustomizations" -Filter "CUDA*" | ForEach-Object { echo "  $($_.Name)" }

        # Set CMAKE_CUDA_COMPILER for vcpkg/CMake to find nvcc
        $nvccPath = Join-Path $env:CUDA_PATH "bin\nvcc.exe"
        if (Test-Path $nvccPath) {
          echo "CMAKE_CUDA_COMPILER=$nvccPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "Set CMAKE_CUDA_COMPILER=$nvccPath"
        }

        # Also set CUDAToolkit_ROOT for FindCUDAToolkit.cmake
        echo "CUDAToolkit_ROOT=$env:CUDA_PATH" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "Set CUDAToolkit_ROOT=$env:CUDA_PATH"
      shell: pwsh

    - name: Install cuDNN 8.9.5 via pip
      run: |
        pip install nvidia-cudnn-cu11==8.9.5.29
        echo "cuDNN 8.9.5.29 installed"
      shell: cmd

    - name: Copy cuDNN files to CUDA Toolkit
      run: |
        $pipShowOutput = pip show nvidia-cudnn-cu11
        $location = ($pipShowOutput | Select-String -Pattern "^Location: (.*)").Matches.Groups[1].Value
        $cudnnPath = Join-Path $location "nvidia\cudnn"
        $cudaPath = $env:CUDA_PATH

        echo "cuDNN source: $cudnnPath"
        echo "CUDA target: $cudaPath"

        # Copy DLLs to bin
        Get-ChildItem -Recurse -Filter "*.dll" $cudnnPath | ForEach-Object {
          Copy-Item $_.FullName (Join-Path $cudaPath "bin\$($_.Name)") -Force
          echo "Copied: $($_.Name) -> bin\"
        }

        # Copy headers to include
        Get-ChildItem -Recurse -Filter "*.h" $cudnnPath | ForEach-Object {
          Copy-Item $_.FullName (Join-Path $cudaPath "include\$($_.Name)") -Force
          echo "Copied: $($_.Name) -> include\"
        }

        # Copy libs to lib/x64
        $libPath = Join-Path $cudaPath "lib\x64"
        Get-ChildItem -Recurse -Filter "*.lib" $cudnnPath | ForEach-Object {
          Copy-Item $_.FullName (Join-Path $libPath $_.Name) -Force
          echo "Copied: $($_.Name) -> lib\x64\"
        }

        # Verify key files exist
        $cudnnHeader = Join-Path $cudaPath "include\cudnn.h"
        $cudnnLib = Join-Path $cudaPath "lib\x64\cudnn.lib"
        $cudnnLib8 = Join-Path $cudaPath "lib\x64\cudnn8.lib"

        if (Test-Path $cudnnHeader) {
          echo "SUCCESS: cudnn.h found at $cudnnHeader"
        } else {
          echo "ERROR: cudnn.h NOT found"
          exit 1
        }

        # Determine library path (cudnn.lib or cudnn8.lib)
        $actualLib = ""
        if (Test-Path $cudnnLib) {
          echo "SUCCESS: cudnn.lib found"
          $actualLib = $cudnnLib
        } elseif (Test-Path $cudnnLib8) {
          echo "SUCCESS: cudnn8.lib found"
          $actualLib = $cudnnLib8
        } else {
          echo "ERROR: No cudnn library found"
          exit 1
        }

        # Export cuDNN paths for vcpkg/CMake to find
        # These are used by vcpkg's FindCUDNN.cmake
        echo "CUDNN_INCLUDE_DIR=$cudaPath\include" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "CUDNN_LIBRARY=$actualLib" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "CUDNN_ROOT=$cudaPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "CUDNN_ROOT_DIR=$cudaPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

        echo ""
        echo "=== Environment variables set for vcpkg/CMake ==="
        echo "CUDNN_INCLUDE_DIR=$cudaPath\include"
        echo "CUDNN_LIBRARY=$actualLib"
        echo "CUDNN_ROOT=$cudaPath"
        echo "CUDNN_ROOT_DIR=$cudaPath"
      shell: pwsh

    - name: Create vcpkg binary cache directory
      run: if (!(Test-Path "${{env.VCPKG_DEFAULT_BINARY_CACHE}}")) { New-Item -ItemType Directory -Path "${{env.VCPKG_DEFAULT_BINARY_CACHE}}" -Force }
      shell: pwsh
      continue-on-error: true

    - name: Configure CMake with CUDA
      working-directory: ${{github.workspace}}/build
      run: |
        # Use VS 2019 toolset (v142) for CUDA 11.8 compatibility
        # The cuda= option tells CMake where to find CUDA MSBuildExtensions
        # Format: -T "v142,cuda=C:\path\to\cuda" (must include cuda= to use CUDA_PATH)
        # See: https://cmake.org/cmake/help/latest/variable/CMAKE_VS_PLATFORM_TOOLSET_CUDA_CUSTOM_DIR.html
        $cudaPath = $env:CUDA_PATH
        echo "Using CUDA_PATH: $cudaPath"
        cmake -B . -DENABLE_WINDOWS=ON -DENABLE_LINUX=OFF -A x64 -T "v142,cuda=$cudaPath" `
          -DCMAKE_TOOLCHAIN_FILE=${{env.CMAKE_TC_FILE}} `
          -DVCPKG_TARGET_TRIPLET=x64-windows-cuda `
          -DVCPKG_OVERLAY_TRIPLETS="${{github.workspace}}/vcpkg/triplets/community" `
          -DCMAKE_BUILD_TYPE=Release `
          -DENABLE_CUDA=ON `
          ../base
      shell: pwsh

    - name: Remove files not needed for the build
      working-directory: ${{github.workspace}}
      run: |
        Remove-Item vcpkg/downloads -Recurse -Force -ErrorAction SilentlyContinue
        Remove-Item * -Recurse -Force -Include *.pdb,*.ilk -ErrorAction SilentlyContinue
      shell: pwsh
      continue-on-error: true

    - name: Build
      working-directory: ${{github.workspace}}/build
      run: cmake --build . --config Release -j 6

    # NOTE: CUDA DLLs are NOT bundled in the SDK artifact.
    # - DELAYLOAD allows the exe to start on systems without CUDA
    # - On GPU systems (self-hosted runners), CUDA DLLs are installed system-wide
    # - This keeps the SDK artifact small (~200 MB instead of ~1.4 GB)

    - name: Diagnose DLL dependencies
      run: |
        echo "=== Checking DLL dependencies ==="

        # Use dumpbin to check what DLLs the exe needs
        $exePath = "${{github.workspace}}/build/Release/aprapipesut.exe"
        echo "Checking dependencies of: $exePath"

        # Check if Visual Studio tools are available
        $vsPath = "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC"
        $latestVS = Get-ChildItem $vsPath | Sort-Object Name -Descending | Select-Object -First 1
        $dumpbinPath = "$($latestVS.FullName)\bin\Hostx64\x64\dumpbin.exe"

        if (Test-Path $dumpbinPath) {
          echo "Using dumpbin at: $dumpbinPath"
          & $dumpbinPath /dependents $exePath | Select-Object -First 100
        } else {
          echo "dumpbin not found, skipping dependency check"
        }

        # Check if nvcuda.dll exists on this system
        echo ""
        echo "=== Checking for CUDA driver (nvcuda.dll) ==="
        $nvcudaPath = "C:\Windows\System32\nvcuda.dll"
        if (Test-Path $nvcudaPath) {
          echo "FOUND: nvcuda.dll at $nvcudaPath"
        } else {
          echo "NOT FOUND: nvcuda.dll (expected - no NVIDIA GPU on this runner)"
        }

        # Try running the exe and capture error
        # Note: We don't actually run the exe here to avoid potential hangs
        # The "List Test cases" step with timeout will do the actual test
        echo ""
        echo "=== Skipping exe execution in diagnostics (will be tested in List Test cases step) ==="
      shell: pwsh
      timeout-minutes: 2
      continue-on-error: true

    - name: List Test cases
      run: |
        ${{env.TEST_EXE}} --list_content > tests.txt
      timeout-minutes: 1
      continue-on-error: true

    - name: Run Tests
      run: |
        ${{env.TEST_EXE}} --log_format=JUNIT --log_sink=CI_test_result_Windows-Build-Test.xml -p -l all || echo 'test execution returned error'
      timeout-minutes: 20
      # CUDA tests skip silently - this is expected behavior

    - name: Upload Test Results
      if: ${{ always() }}
      continue-on-error: true
      uses: actions/upload-artifact@v4
      with:
        name: TestResults_Windows-Build-Test
        path: |
          CI_test_result_Windows-Build-Test.xml
          ${{ github.workspace }}/data/SaveOrCompareFail/**

    - name: Upload build logs
      if: ${{ always() }}
      uses: actions/upload-artifact@v4
      with:
        name: BuildLogs_Windows-Build-Test
        path: |
          ${{ github.workspace }}/vcpkg/buildtrees/**/*.log
          ${{ github.workspace }}/vcpkg/buildtrees/**/*.txt
          ${{ github.workspace }}/vcpkg_installed/vcpkg/*
          tests.txt
      continue-on-error: true

    # Package and upload SDK artifact for distribution and GPU testing
    - name: Package SDK Artifact
      if: success()
      run: |
        $sdkDir = "${{github.workspace}}/sdk"
        $buildDir = "${{github.workspace}}/build/Release"
        $includeDir = "${{github.workspace}}/base/include"

        # Create SDK directory structure
        New-Item -ItemType Directory -Path "$sdkDir/bin" -Force | Out-Null
        New-Item -ItemType Directory -Path "$sdkDir/lib" -Force | Out-Null
        New-Item -ItemType Directory -Path "$sdkDir/include" -Force | Out-Null

        # Copy binaries (exe only - DLLs from vcpkg are in PATH)
        # Note: Don't copy CUDA DLLs - they're delay-loaded and available system-wide on GPU runners
        Copy-Item "$buildDir/*.exe" "$sdkDir/bin/" -Force
        # Copy only non-CUDA DLLs (vcpkg dependencies like opencv, ffmpeg, etc.)
        Get-ChildItem "$buildDir/*.dll" | Where-Object {
          $_.Name -notmatch "^(cudart|cublas|cufft|cudnn|npp|nvjpeg)"
        } | ForEach-Object {
          Copy-Item $_.FullName "$sdkDir/bin/" -Force
        }

        # Copy libraries (exclude PDB files)
        Get-ChildItem "$buildDir/*.lib" | Where-Object { $_.Name -notmatch "\.pdb$" } | ForEach-Object {
          Copy-Item $_.FullName "$sdkDir/lib/" -Force
        }

        # Copy headers
        Copy-Item "$includeDir/*" "$sdkDir/include/" -Recurse -Force -ErrorAction SilentlyContinue

        # Calculate and report SDK size
        $binSize = (Get-ChildItem "$sdkDir/bin" -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB
        $libSize = (Get-ChildItem "$sdkDir/lib" -Recurse -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum).Sum / 1MB

        echo "=== SDK Contents ==="
        echo "bin/ (${binSize:N1} MB):"
        Get-ChildItem "$sdkDir/bin" | ForEach-Object { echo "  $($_.Name) ($([math]::Round($_.Length/1MB, 1)) MB)" }
        echo "lib/ (${libSize:N1} MB):"
        Get-ChildItem "$sdkDir/lib" -ErrorAction SilentlyContinue | ForEach-Object { echo "  $($_.Name)" }
        echo "include/:"
        Get-ChildItem "$sdkDir/include" -ErrorAction SilentlyContinue | ForEach-Object { echo "  $($_.Name)" }
        echo ""
        echo "Total SDK size: $([math]::Round($binSize + $libSize, 1)) MB"
      shell: pwsh

    - name: Upload SDK Artifact
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: aprapipes-sdk-windows-x64
        path: ${{ github.workspace }}/sdk/
        retention-days: 7

  publish-results:
    name: Publish Test Results
    needs: build-test
    runs-on: ubuntu-latest
    if: always()
    permissions:
      checks: write
      pull-requests: write

    steps:
      - name: Pull ghcr.io/enricomi/publish-unit-test-result-action:v2.21.0
        run: docker pull ghcr.io/enricomi/publish-unit-test-result-action:v2.21.0

      - name: Download Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Display structure of downloaded files
        run: ls -R
        working-directory: artifacts

      - name: Publish
        uses: EnricoMi/publish-unit-test-result-action@v2.21.0
        with:
          files: artifacts/**/CI_test_result_*.xml
