name: Experiment-02-Windows-Runtime-CUDA-Detection

# EXPERIMENT: Can we detect CUDA at runtime using LoadLibrary on Windows?
# GOAL: Test if we can dynamically load CUDA DLLs and function pointers
# SUCCESS CRITERIA:
#   1. Compile WITHOUT linking to CUDA libraries
#   2. Use LoadLibrary to load cudart64_*.dll at runtime
#   3. Use GetProcAddress to get cudaGetDeviceCount function pointer
#   4. Call cudaGetDeviceCount via function pointer (returns 0 devices is OK)
#   5. Program handles missing CUDA gracefully (no crash)

on:
  workflow_dispatch:  # Manual trigger only
  # DISABLED: Experiment proven successful Dec 17, 2024. Delete after CI-Windows-Unified succeeds.
  # push:
  #   branches:
  #     - feature/get-rid-of-nocuda-builds
  #   paths:
  #     - '.github/workflows/experiment-02-windows-runtime-cuda-detection.yml'

jobs:
  test-runtime-cuda-detection:
    runs-on: windows-latest

    steps:
      - name: Check Windows Version
        run: |
          echo "=== Windows Environment ==="
          systeminfo | findstr /B /C:"OS Name" /C:"OS Version"
        shell: cmd

      - name: Install CUDA Toolkit 11.8 using Jimver action
        uses: Jimver/cuda-toolkit@v0.2.29
        id: cuda-toolkit
        with:
          cuda: '11.8.0'
          sub-packages: '["nvcc", "cudart", "visual_studio_integration"]'

      - name: Verify CUDA Installation
        run: |
          echo "=== Verifying CUDA Installation ==="
          echo "CUDA_PATH=$env:CUDA_PATH"
          nvcc --version
        shell: pwsh

      - name: Test Runtime CUDA Detection (Dynamic Loading)
        run: |
          echo "=== Testing Runtime CUDA Detection ==="

          REM Create test program that uses LoadLibrary/GetProcAddress
          (
          echo #include ^<windows.h^>
          echo #include ^<stdio.h^>
          echo.
          echo typedef int ^(*cudaGetDeviceCount_t^)^(int*^);
          echo typedef int ^(*cudaGetErrorString_t^)^(int^);
          echo typedef const char* ^(*cudaGetErrorName_t^)^(int^);
          echo.
          echo int main^(^) {
          echo     printf^("=== Runtime CUDA Detection Test ^(Windows^) ===\n"^);
          echo.
          echo     // Try to load CUDA runtime DLL
          echo     HMODULE cudart = LoadLibraryA^("cudart64_118.dll"^);
          echo     if ^(!cudart^) {
          echo         cudart = LoadLibraryA^("cudart64_110.dll"^);
          echo     }
          echo     if ^(!cudart^) {
          echo         cudart = LoadLibraryA^("cudart64_11.dll"^);
          echo     }
          echo.
          echo     if ^(!cudart^) {
          echo         printf^("CUDA runtime DLL not found - CUDA not available\n"^);
          echo         printf^("This is OK - runtime detection works!\n"^);
          echo         return 0;
          echo     }
          echo.
          echo     printf^("CUDA runtime DLL loaded successfully\n"^);
          echo.
          echo     // Get function pointers
          echo     cudaGetDeviceCount_t cudaGetDeviceCount_ptr = ^(cudaGetDeviceCount_t^)GetProcAddress^(cudart, "cudaGetDeviceCount"^);
          echo     if ^(!cudaGetDeviceCount_ptr^) {
          echo         printf^("Failed to get cudaGetDeviceCount function pointer\n"^);
          echo         FreeLibrary^(cudart^);
          echo         return 1;
          echo     }
          echo.
          echo     printf^("cudaGetDeviceCount function pointer obtained\n"^);
          echo.
          echo     // Call cudaGetDeviceCount
          echo     int deviceCount = 0;
          echo     int error = cudaGetDeviceCount_ptr^(^&deviceCount^);
          echo.
          echo     printf^("cudaGetDeviceCount returned: %%d\n", error^);
          echo     printf^("Device count: %%d\n", deviceCount^);
          echo.
          echo     FreeLibrary^(cudart^);
          echo.
          echo     printf^("SUCCESS: Runtime CUDA detection works!\n"^);
          echo     return 0;
          echo }
          ) > test_runtime_cuda.c

          REM Setup Visual Studio environment with v142 toolset (VS 2019)
          call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat" x64 -vcvars_ver=14.29

          REM Compile WITHOUT linking to CUDA - just plain C compiler
          cl test_runtime_cuda.c /Fe:test_runtime_cuda.exe
          if errorlevel 1 (
            echo Compilation failed!
            exit /b 1
          )
          echo Compilation successful!

          REM Run the test
          test_runtime_cuda.exe
        shell: cmd

      - name: Test Runtime Detection Without CUDA (Simulate Missing CUDA)
        run: |
          echo "=== Testing Graceful Degradation ==="

          REM Create test that handles missing CUDA gracefully
          (
          echo #include ^<windows.h^>
          echo #include ^<stdio.h^>
          echo.
          echo typedef int ^(*cudaGetDeviceCount_t^)^(int*^);
          echo.
          echo int main^(^) {
          echo     printf^("=== Testing Missing CUDA Handling ===\n"^);
          echo.
          echo     // Try to load non-existent CUDA DLL
          echo     HMODULE cudart = LoadLibraryA^("cudart64_999.dll"^);
          echo.
          echo     if ^(!cudart^) {
          echo         printf^("CUDA not available - application continues without CUDA\n"^);
          echo         printf^("SUCCESS: Graceful degradation works!\n"^);
          echo         return 0;
          echo     }
          echo.
          echo     printf^("Unexpected: Found CUDA DLL\n"^);
          echo     FreeLibrary^(cudart^);
          echo     return 1;
          echo }
          ) > test_no_cuda.c

          REM Setup Visual Studio environment
          call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat" x64 -vcvars_ver=14.29

          REM Compile WITHOUT any CUDA dependencies
          cl test_no_cuda.c /Fe:test_no_cuda.exe
          if errorlevel 1 (
            echo Compilation failed!
            exit /b 1
          )

          REM Run test - should succeed even without CUDA
          test_no_cuda.exe
        shell: cmd

      - name: Test With cudart.dll in PATH
        run: |
          echo "=== Testing With CUDA DLL in PATH ==="

          REM Create advanced test
          (
          echo #include ^<windows.h^>
          echo #include ^<stdio.h^>
          echo.
          echo typedef int ^(*cudaGetDeviceCount_t^)^(int*^);
          echo.
          echo int main^(^) {
          echo     printf^("=== Testing CUDA Detection With PATH ===\n"^);
          echo.
          echo     // Add CUDA bin to PATH if not already there
          echo     printf^("CUDA_PATH: %%s\n", getenv^("CUDA_PATH"^) ? getenv^("CUDA_PATH"^) : "not set"^);
          echo.
          echo     // Try versioned DLLs first, then generic
          echo     const char* dll_names[] = {
          echo         "cudart64_118.dll",
          echo         "cudart64_110.dll",
          echo         "cudart64_11.dll",
          echo         "cudart64.dll",
          echo         NULL
          echo     };
          echo.
          echo     HMODULE cudart = NULL;
          echo     int i = 0;
          echo     while ^(dll_names[i] ^&^& !cudart^) {
          echo         printf^("Trying to load: %%s\n", dll_names[i]^);
          echo         cudart = LoadLibraryA^(dll_names[i]^);
          echo         if ^(cudart^) {
          echo             printf^("Successfully loaded: %%s\n", dll_names[i]^);
          echo         }
          echo         i++;
          echo     }
          echo.
          echo     if ^(!cudart^) {
          echo         printf^("No CUDA DLL found\n"^);
          echo         return 0;
          echo     }
          echo.
          echo     cudaGetDeviceCount_t cudaGetDeviceCount_ptr = ^(cudaGetDeviceCount_t^)GetProcAddress^(cudart, "cudaGetDeviceCount"^);
          echo     if ^(cudaGetDeviceCount_ptr^) {
          echo         int deviceCount = 0;
          echo         int error = cudaGetDeviceCount_ptr^(^&deviceCount^);
          echo         printf^("cudaGetDeviceCount: error=%%d, count=%%d\n", error, deviceCount^);
          echo     }
          echo.
          echo     FreeLibrary^(cudart^);
          echo     printf^("SUCCESS: Advanced runtime detection works!\n"^);
          echo     return 0;
          echo }
          ) > test_with_path.c

          REM Setup Visual Studio environment
          call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat" x64 -vcvars_ver=14.29

          REM Compile
          cl test_with_path.c /Fe:test_with_path.exe

          REM Add CUDA bin to PATH
          set PATH=%CUDA_PATH%\bin;%PATH%

          REM Run test
          test_with_path.exe
        shell: cmd

      - name: Summary
        if: always()
        run: |
          echo ""
          echo "======================================"
          echo "EXPERIMENT 02 (WINDOWS): RESULTS"
          echo "======================================"
          echo ""
          echo "This experiment validates:"
          echo "  ✓ LoadLibrary can load CUDA DLLs at runtime"
          echo "  ✓ GetProcAddress can get CUDA function pointers"
          echo "  ✓ CUDA functions callable via function pointers"
          echo "  ✓ Graceful degradation when CUDA not available"
          echo "  ✓ No CUDA link-time dependencies needed"
          echo ""
          echo "Conclusion: Windows runtime CUDA detection works!"
          echo "Next Step: Implement CudaAdapter for Windows"
          echo "======================================"
        shell: pwsh
